<!DOCTYPE html>
<!--TO DO: refer to shapes, graph variable can be used to get node objects and set the parameters-->

<html lang="en-us">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      .node-label {
        font-size: 12px;
        padding: 1px 4px;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.5);
        user-select: none;
      }
      .slider_overlay {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        background-color: grey;
      }
      body {
        height: 100vh;
        width: 100vw;
      }

      body {
        margin: 0;
        display: flex;
        flex-direction: row;
        overflow: hidden !important;
      }
      h1 {
        font-size: 1em;
        padding-right: 1vw;
      }
      #interface {
        height: 90%;
        width: 33.3333%;
        display: flex;
        flex-direction: column;
        padding: 1%;
      }

      #add_node {
        height: 20%;
        width: 100%;
        resize: none;
      }

      #add_submit {
        height: min-content;
        width: 100%;
      }

      #load_file,
      #download_file {
        height: 100%;
        width: 50%;
      }

      #db_buttons,
      #submit_button {
        display: flex;
        flex-direction: row;
        height: 7.5%;
        width: 100%;
      }

      #submit_button {
        flex-direction: row-reverse !important;
      }

      #drop_area {
        position: fixed;
        top: 20%;
        bottom: 20%;
        right: 20%;
        display: none;
        left: 20%;
        text-align: center;
        color: rgb(180, 180, 180);
        background: white;
        height: 60%;
        line-height: 100%;
        width: 60%;
        z-index: 10;
        border: 2px solid grey;
        border-radius: 5px;
        vertical-align: middle;
      }

      .dummy {
        height: auto;
        width: auto;
      }

      #drag_text {
        position: absolute;
        top: 50%;
        bottom: 50%;
        right: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min-content;
        white-space: nowrap;
      }

      .close {
        color: grey;
        position: absolute;
        top: 5%;
        right: 2.5%;
        font-size: 3vw;
      }

      #node_lister {
        display: flex;
        flex-direction: column;
        overflow-y: scroll;
        height: 80%;
      }
      .close:hover {
        cursor: pointer;
      }

      .switch {
        font-size: 1vw;
        position: relative;
        display: inline-block;
        width: 3.6em;
        height: 4em;
        font-family: Arial, Helvetica, sans-serif;
        border-radius: 5px;
      }
      .slider_text {
        font-size: 1vw;
        position: absolute;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #000066;
        -webkit-transition: 0.4s;
        transition: 0.4s;
        border-radius: 5px;
      }

      .slider:before {
        position: absolute;
        height: 1.4em;
        content: "TXT";
        color: #000066;
        width: 2.8em;
        vertical-align: sub;
        display: flex;
        justify-content: center;
        align-content: center;
        flex-direction: column;
        text-align: center;
        background-color: white;
        -webkit-transition: 0.4s;
        transition: 0.4s;
        top: 0.1em;
        left: 1%;
        right: 1%;
        border-radius: 5px;
      }

      input:checked + .slider {
        background-color: maroon;
        color: maroon;
      }

      input:focus + .slider {
        box-shadow: 0 0 1px maroon;
      }
      #search_bar {
        height: 1.5em;
        width: 100%;
        resize: none;
      }
      input:checked + .slider:before {
        content: "IMG";
        color: maroon;
        -webkit-transform: translateY(2.4em);
        -ms-transform: translateY(2.4em);
        transform: translateY(2.4em);
      }

      .node_content {
        resize: none;
        overflow-y: scroll;
      }
      .content_container {
        display: flex;
        flex-direction: row;
      }
      .action_buttons {
        width: 20%;
        height: 100%;
        display: none;
      }
      #node_actions {
        width: 7%;
        height: 5%;
        position: absolute;
        display: flex;
        flex-flow: row nowrap;
      }

    </style>
    <script src="//unpkg.com/d3-dsv"></script>
    <script src="//unpkg.com/dat.gui"></script>
    <script src="//unpkg.com/d3-octree"></script>
    <script src="//unpkg.com/d3-force-3d"></script>
    <script src="//unpkg.com/three@0.142.0/build/three.js"></script>
    <script src="//unpkg.com/three@0.142.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="//unpkg.com/3d-force-graph"></script>
    <!--<script src="../../dist/3d-force-graph.js"></script>-->
    <title>Charlette's Web</title>
  </head>

  <body>
    <div id="drop_area">
      <span class="close" id="close_drop">&times;</span>
      <span id="drag_text">Drag and drop file here</span>
    </div>
    <div id="node_actions">
      <button type="button" class="action_buttons" id="focus_button">F</button>
      <button type="button" class="action_buttons" id="select_button">
        Se
      </button>
      <button type="button" class="action_buttons" id="split_button">Sp</button>
      <button type="button" class="action_buttons" id="prune_button">P</button>
      <button type="button" class="action_buttons" id="unprune_button">
        UP
      </button>
    </div>
    <div id="interface">
      <div id="title_bar_div" data-editing="false">
        <h1 style="display: block">Title</h1>
        <textarea
          id="title_bar_textarea"
          rows="1"
          column="120"
          style="display: none"
        ></textarea>
      </div>
      <div id="search_bar_div">
        <textarea id="search_bar" rows="1" column="120"></textarea>
      </div>
      <div id="node_lister"></div>
      <div id="submit_button">
        <div class="dummy"></div>
        <button type="button" id="add_submit">Add Node</button>
        <div class="dummy"></div>
      </div>
      <div id="db_buttons">
        <div class="dummy"></div>
        <button type="button" id="load_file">load database</button>
        <button type="button" id="download_file">download database</button>
      </div>
    </div>
    <div id="3d-graph">
<div style="position: relative;"><div><div class="scene-container" style="position: relative; width: 696px; height: 440px;"><div class="scene-nav-info">Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan</div><div class="scene-tooltip" style="top: 206.717px; left: 358.645px; transform: translate(-51.5294%, 21px);">1</div><canvas data-engine="three.js r142" width="1280" height="809" style="display: block; touch-action: none; width: 696px; height: 440px;" class="clickable"></canvas><div style="overflow: hidden; position: absolute; top: 0px; pointer-events: none; width: 696px; height: 440px;"><div class="node-label" id="node_1" draggable="false" style="visibility: visible; color: rgb(0, 255, 255); position: absolute; user-select: none; transform: translate(-50%, -50%) translate(347.81px, 197.969px); z-index: 1;"></div></div></div></div><div class="graph-info-msg"></div></div>
    </div>
    <script>
      class _Node {
        constructor(id, text, name, val, links, neighbors, split) {
          this.id = id;
          this.text = text;
          this.name = name;
          this.val = val;
          this.links = links;
          this.neighbors = neighbors;
          this.split = split;
        }
      }
    </script>
    <script type="module">
      import { UnrealBloomPass } from "//cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js";
      const ENTIRE_SCENE = 0;
      const BLOOM_SCENE = 1;
      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_SCENE);

      const materials = {};
      // controls

      // graph config
      const NODE_REL_SIZE = 6;

      // Graph Data starter
      const nodes = [
        {
          id: 1,
          name: "1",
          val: 10,
          text: "",
          neighbors: [],
          links: [],
          split: "",
          index: 0,
          label: 1,
        },
      ];
      const links = [
      ];
      let gData = {
        nodes,
        links,
      };
      // node_container creator for start
      const node_container = document.getElementById("node_lister");
      gData.nodes.forEach((node) => {
        if (parseInt(node.name) > 0) {
          create_node(node);
        }
      });

      // create neighbors for animation
      gData.links.forEach((link) => {
        const a = gData.nodes[link.source - 1];
        const b = gData.nodes[link.target - 1];
        if (a.neighbors === null) {
          a.neighbors = [];
        }
        if (b.neighbors === null) {
          b.neighbors = [];
        }
        !a.neighbors && (a.neighbors = []);
        !b.neighbors && (b.neighbors = []);
        a.neighbors.push(b);
        b.neighbors.push(a);

        if (a.links === null) {
          a.links = [];
        }
        if (b.links === null) {
          b.links = [];
        }
        !a.links && (a.links = []);
        !b.links && (b.links = []);
        a.links.push(link);
        b.links.push(link);
      });
      gData.nodes.forEach((node) => {
        if (Object.keys(node).indexOf("neighbors") === -1) {
          node.neighbors = [];
        }
        if (Object.keys(node).indexOf("links") === -1) {
          node.links = [];
        }
      });

      // bloom config
      const bloomPass = new UnrealBloomPass();
      bloomPass.strength = 1;
      bloomPass.radius = 1;
      bloomPass.threshold = 0.5;
      const darkMaterial = new THREE.MeshBasicMaterial({
        color: "black",
      });
      const selectedNodes = new Set();
      let visible_node;
      const visible_nodes = new Set();
      const highlightLinks = new Set();
      //prune tree
      const prune_keys = new Set();
      const getPrunedTree = () => {
        const pruned_nodes = [];
        const pruned_links = [];
        if (prune_keys.size === 0) {
          return gData;
        } else {
          prune_keys.forEach((node) => {
            if (node.split !== "" && !prune_keys.has(gData.nodes[node.split - 1])) {
              prune_keys.add(gData.nodes[node.split - 1]);
            }
            node.neighbors.forEach((neighbor) => {
            if(!pruned_nodes.includes(neighbor)){
              pruned_nodes.push(neighbor);
              }
            });
            if(!pruned_nodes.includes(node)){
            pruned_nodes.push(node);
            }
            console.log("hi1");
            node.links.forEach((link) => {
            if(!pruned_links.includes(link)){
              pruned_links.push(link);
              }
            });
            console.log("hi2");
          });
          console.log(pruned_nodes);
          console.log(pruned_links);
          console.log(prune_keys);
          return { nodes: pruned_nodes, links: pruned_links };
        }
      };
      // graph definition
      const Graph = ForceGraph3D({
        extraRenderers: [new THREE.CSS2DRenderer()],
        rendererConfig: { logarithmicDepthBuffer: true },
      })(document.getElementById("3d-graph"));
      Graph.graphData(getPrunedTree())
        .width((document.defaultView.innerWidth * 2) / 3)
        // node settings
        .nodeLabel((node) => node.label)
        .nodeColor((node) => {
        const colors = [[new Three.Color(0.5,0,0),new Three.Color(1,0,0)],[new Three.Color(0,0.5,0.5),new Three.Color(0,1,1)]];
        let temp_color;
          if (node.split != "" && parseInt(node.name) < 0) {
            temp_color = 0;
          }
          else{
          temp_color = 1;
          }
          let selected;
            if(selectedNode.has(node)){
            selected = 1;
            }
            else{
            selected = 0
            }
          return colors[temp_color][selected];
          })
        .nodeVisibility((node) => node.text !== "dummy")
        .nodeThreeObject((node) => {
          let mesh;
          const group = new THREE.Group();
          if (node.split != "") {
            if (parseInt(node.name) < 0) {
              // negation

              let geom = new THREE.SphereGeometry(
                NODE_REL_SIZE,
                32,
                16,
                Math.PI * 1.5,
                Math.PI,
                Math.PI,
                Math.PI
              );
              //                geom.scale(-1,1,1);
              mesh = new THREE.Mesh(
                geom,
                new THREE.MeshBasicMaterial({
                  color: new THREE.Color(0.5, 0, 0),
                  side: THREE.DoubleSide,
                  //                  shadowSide: THREE.BackSide
                  depthFunc: THREE.LessDepth,
                })
              );

              mesh.updateMatrix();
              //              if (
              //                Graph.graphData()
              //                  .nodes.at(parseInt(node.split) - 1)
              //                  .hasOwnProperty("__threeObj")
              //              ) {
              //                console.log(Graph.graphData());
              //                const sibling_mesh =
              //                  Graph.graphData().nodes[parseInt(node.split) - 1];
              //                ["x", "y", "z"].forEach(
              //                  (coord) => (node[`f${coord}`] = sibling_mesh[coord])
              //                );
              //              }
            } else {
              // non-negated
              let geom = new THREE.SphereGeometry(
                NODE_REL_SIZE,
                64,
                32,
                Math.PI * 0.5,
                Math.PI,
                Math.PI,
                Math.PI
              );
              geom.scale(1, 1, 1);
              mesh = new THREE.Mesh(
                geom,
                new THREE.MeshBasicMaterial({
                  color: new THREE.Color(0, 0.5, 0.5),
                  side: THREE.DoubleSide,
                  //                    depthFunc:THREE.GreaterDepth
                })
              );
              mesh.updateMatrix();
            }
          } else {
            // if not split, create full sphere
            mesh = new THREE.Mesh(
              new THREE.SphereGeometry(NODE_REL_SIZE),
              new THREE.MeshBasicMaterial({
                color: new THREE.Color(0, 0.5, 0.5),
              })
            );
          }
          group.add(mesh);
          // TODO check what this does
          if (node.text === "dummy") {
            group.visible = false;
            return group;
          }

          // css object creator; creates div and add it as three.obj
          let css_obj;
          // if text is text
          if (!is_image(node.text)) {
            const nodeEl = document.createElement("div");
            nodeEl.textContent = node.text;
            nodeEl.className = "node-label";
            nodeEl.id = `node_${node.id}`;
            nodeEl.style.visibility = "hidden";
            nodeEl.style.color = `rgb(${mesh.material.color.r * 2 * 255},${
              mesh.material.color.g * 2 * 255
            },${mesh.material.color.b * 2 * 255})`;
            css_obj = new THREE.CSS2DObject(nodeEl);
          }
          // if text is image link
          else {
            const nodeEl = document.createElement("img");
            nodeEl.src = node.text;
            nodeEl.className = "node-label";
            nodeEl.id = `node_${node.id}`;
            nodeEl.style.visibility = "hidden";
            nodeEl.style.objectFit = "contain";
            nodeEl.style.maxWidth = "100px";
            nodeEl.style.maxHeight = "100px";

            nodeEl.style.color = `rgb(${mesh.material.color.r * 2 * 255},${
              mesh.material.color.g * 2 * 255
            },${mesh.material.color.b * 2 * 255})`;
            css_obj = new THREE.CSS2DObject(nodeEl);
          }
          // TODO check what this does
          if (node.split != "") {
            if (parseInt(node.name) < 0) {
              //     mesh.position.set(-1*node.val,0,0);
            } else {
              //      mesh.position.set(1*node.val,0,0);
            }
          }
          group.add(css_obj);
          return group;
        })
        .onNodeHover((node, prev_node) => {
            console.log(node);
          if (node!=null) {
          if(visible_node!= null){
            visible_node.__threeObj.children[1].element.style.visibility = "hidden";
          }
            if (node.text !== "dummy") {
              node.__threeObj.children[1].element.style.visibility = "visible";
              visible_node = node;
            }
          } else if (visible_node != null) {
          console.log(visible_node);
            if (
              !selectedNodes.has(visible_node) &&
              !visible_nodes.has(visible_node)
            ) {
              visible_node.__threeObj.children[1].element.style.visibility =
                "hidden";
            }
            visible_node = null;
          }
        })
        .onNodeDrag((node, translate) => {
          if (selectedNodes.has(node)) {
            // moving a selected node
            [...selectedNodes]
              .filter((selNode) => selNode !== node) // don't touch node being dragged
              .forEach((node) => {
                ["x", "y", "z"].forEach(
                  (coord) =>
                    (node[`f${coord}`] = node[coord] + translate[coord])
                );
                node.neighbors.forEach((neighbor) => {
                  if (!Number.isInteger(parseInt(neighbor.name))) {
                    ["x", "y", "z"].forEach(
                      (coord) =>
                        (neighbor[`f${coord}`] =
                          neighbor[coord] + translate[coord])
                    );
                  }
                });
              }); // translate other nodes by same amount
            console.log(node.split);
          }
          if (node.split !== "") {
            if (parseInt(node.name) < 0) {
              const main = gData.nodes[node.split - 1];
              ["x", "y", "z"].forEach((coord) => {
                if (coord !== "x") {
                  main[`f${coord}`] = node[coord];
                } else {
                  main[`f${coord}`] = node[coord] + Graph.nodeRelSize() * 3.01;
                }
              });
            } else {
              console.log(node.split);
              const neg = gData.nodes[node.split - 1];
              ["x", "y", "z"].forEach((coord) => {
                if (coord !== "x") {
                  neg[`f${coord}`] = node[coord];
                } else {
                  neg[`f${coord}`] = node[coord] - Graph.nodeRelSize() * 3.01;
                }
              });
            }
          }
        })
        .onNodeDragEnd((node) => {
          if (selectedNodes.has(node)) {
            // finished moving a selected node
            [...selectedNodes]
              .filter((selNode) => selNode !== node) // don't touch node being dragged
              .forEach((node) => {
                node.neighbors.forEach((neighbor) => {
                  if (!Number.isInteger(parseInt(neighbor.name))) {
                    console.log(neighbor.links.length);
                    let avg_pos = { x: 0, y: 0, z: 0 };
                    let targeter;
                    neighbor.links.forEach((link) => {
                      if (link.target === neighbor) {
                        ["x", "y", "z"].forEach((coord) => {
                          avg_pos[coord] += link.source[coord];
                        });
                      } else {
                        targeter = link.target;
                      }
                    });

                    ["x", "y", "z"].forEach((coord) => {
                      avg_pos[coord] /= neighbor.links.length - 1;
                    });

                    let fin_pos = { x: 0, y: 0, z: 0 };
                    ["x", "y", "z"].forEach((coord) => {
                      fin_pos[coord] = (avg_pos[coord] + targeter[coord]) / 2;
                    });

                    ["x", "y", "z"].forEach((coord) => {
                      neighbor[`f${coord}`] = fin_pos[coord];
                    });
                  }
                });
              }); // unfix controlled nodes
          }
          node.neighbors.forEach((neighbor) => {
            if (!Number.isInteger(parseInt(neighbor.name))) {
              console.log(neighbor.links.length);
              let avg_pos = { x: 0, y: 0, z: 0 };
              let targeter;
              neighbor.links.forEach((link) => {
                if (link.target === neighbor) {
                  ["x", "y", "z"].forEach((coord) => {
                    avg_pos[coord] += link.source[coord];
                  });
                } else {
                  targeter = link.target;
                }
              });

              ["x", "y", "z"].forEach((coord) => {
                avg_pos[coord] /= neighbor.links.length - 1;
              });

              let fin_pos = { x: 0, y: 0, z: 0 };
              ["x", "y", "z"].forEach((coord) => {
                fin_pos[coord] = (avg_pos[coord] + targeter[coord]) / 2;
              });

              ["x", "y", "z"].forEach((coord) => {
                neighbor[`f${coord}`] = fin_pos[coord];
              });
            }
          });
        })
        .onNodeClick((node, event) => {
Graph.d3Force('charge').strength(null);
      Graph.d3Force('link').strength(null);
      Graph.d3Force('center').strength(null);
          if (event.shiftKey) {
            // multi-selection
            selectedNodes.has(node)
              ? selectedNodes.delete(node)
              : selectedNodes.add(node);
            if (selectedNodes.has(node)) {
              node.__threeObj.children[0].material.color.r *= 2;
              node.__threeObj.children[0].material.color.g *= 2;
              node.__threeObj.children[0].material.color.b *= 2;
              node.__threeObj.children[1].element.style.visibility = "visible";
              visible_nodes.add(node);
              visible_node = null;
              if (selectedNodes.size === 1) {
                if (node.links != null) {
                  node.links.forEach((link) => highlightLinks.add(link));
                  updateHighlight();
                }
              } else {
                highlightLinks.clear();
                selectedNodes.forEach((from_node) => {
                  selectedNodes.forEach((to_node) => {
                    if (from_node.links != null) {
                      from_node.links.forEach((link) => {
                        // console.log(link);
                        if (
                          link.source === from_node &&
                          link.target === to_node
                        ) {
                          highlightLinks.add(link);
                        }
                        updateHighlight();
                      });
                    }
                  });
                });
              }
            } else {
              node.__threeObj.children[1].element.style.visibility = "hidden";
              visible_nodes.delete(node);
              node.__threeObj.children[0].material.color.r /= 2;
              node.__threeObj.children[0].material.color.g /= 2;
              node.__threeObj.children[0].material.color.b /= 2;
              highlightLinks.forEach((link) => {
                if (link.source === node || link.target === node) {
                  highlightLinks.delete(link);
                }
                updateHighlight();
              });
            }
          }
          // create link
          else if (event.ctrlKey) {
            if (selectedNodes.size === 0) {
              return;
            }
            // cosole.log(selectedNodes);
            let target_value;
            let targetNode_value;
            if (selectedNodes.size !== 1) {
              const dummy_node = {
                id: gData.nodes.length + 1,
                text: "dummy",
                //                name: `-${node.id}`,
                name: "0",
                val: 0,
                neighbors: [],
                links: [],
                split: "",
                label: 0,
              };
              // dummy_node.__threeObj.visible = 'false';
              let temp_id = "_";
              selectedNodes.forEach((small_node) => {
                temp_id += `${small_node.id}-`;
              });
              dummy_node.name = temp_id;
              const mult_temp_link = {
                source: dummy_node.id,
                target: node.id,
                targetNode: node,
                color: "blue",
              };
              gData.links.push(mult_temp_link);
              dummy_node.neighbors.push(node);
              dummy_node.links.push(mult_temp_link);
              node.neighbors.push(dummy_node);
              node.links.push(mult_temp_link);
              target_value = dummy_node.id;
              targetNode_value = dummy_node;
              gData.nodes.push(dummy_node);
              Graph.graphData(getPrunedTree());

              let avg_pos = { x: 0, y: 0, z: 0 };
              selectedNodes.forEach((small_node) => {
                ["x", "y", "z"].forEach((coord) => {
                  avg_pos[coord] += small_node[coord];
                });
              });

              ["x", "y", "z"].forEach((coord) => {
                avg_pos[coord] /= selectedNodes.size;
              });

              let fin_pos = { x: 0, y: 0, z: 0 };
              ["x", "y", "z"].forEach((coord) => {
                fin_pos[coord] = (avg_pos[coord] + node[coord]) / 2;
              });

              ["x", "y", "z"].forEach((coord) => {
                dummy_node[`f${coord}`] = fin_pos[coord];
              });
            } else {
              target_value = node.id;
              targetNode_value = node;
            }
            selectedNodes.forEach((small_node) => {
              console.log(small_node);
              const temp_link = {
                source: small_node.id,
                target: target_value,
                targetNode: targetNode_value,
                color: "blue",
              };
              let flag = true;
              small_node.links.forEach((link) => {
                if (link.source === small_node && link.target === node) {
                  flag = false;
                }
              });
              if (small_node.id !== node.id && flag) {
                gData.links.push(temp_link);
                small_node.neighbors.push(targetNode_value);
                small_node.links.push(temp_link);
                targetNode_value.neighbors.push(small_node);
                targetNode_value.links.push(temp_link);
              }
            });

            selectedNodes.forEach((selected) => {
              selected.__threeObj.children[0].material.color.r *= 1;
              selected.__threeObj.children[0].material.color.g *= 1;
              selected.__threeObj.children[0].material.color.b *= 1;

              if (selected.links != null) {
                selected.links.forEach((link) => highlightLinks.add(link));
                updateHighlight();
              } else {
                highlightLinks.clear();
                selectedNodes.forEach((from_selected) => {
                  selectedNodes.forEach((to_selected) => {
                    if (from_selected.links != null) {
                      from_selected.links.forEach((link) => {
                        if (
                          link.source === from_selected &&
                          link.target === to_selected
                        ) {
                          highlightLinks.add(link);
                        }
                        updateHighlight();
                      });
                    }
                  });
                });
              }
            });
            Graph.graphData(getPrunedTree());
            Graph.refresh();
            if (selectedNodes.size !== 1) {
              const event = document.createEvent("Event");
              event.initEvent("build", true, true);
              document.dispatchEvent(event);
            }
            selectedNodes.clear();
          } else if (event.altKey) {
            visible_node = null;
            if (visible_nodes.has(node)) {
              node.__threeObj.children[1].element.style.visibility = "hidden";
              visible_nodes.delete(node);
            } else {
              node.__threeObj.children[1].element.style.visibility = "visible";
              visible_nodes.add(node);
            }
          } else {
            // single-selection
            const untoggle =
              selectedNodes.has(node) && selectedNodes.size === 1;
            selectedNodes.clear();
            !untoggle && selectedNodes.add(node);
          }
        })
        // link settings
        .linkDirectionalArrowLength(3.5)
        .linkDirectionalArrowRelPos(0.5)
        .linkColor((link) => link.color)
        .linkWidth((link) => (highlightLinks.has(link) ? 3 : 1))
        .linkVisibility((link) => {
          let source;
          let target;
          console.log(Graph.graphData());
          if (link.source.hasOwnProperty("name")) {
            source = link.source.name;
            target = link.target.name;
          } else if (
            Number.isInteger(link.source) &&
            Number.isInteger(link.target)
          ) {
            source = gData.nodes[link.source - 1].name;
            target = gData.nodes[link.target - 1].name;
          }
          if (parseInt(source) * -1 === parseInt(target)) {
            return false;
          } else {
            return true;
          }
        })
        .onLinkClick((link, event) => {
          if (event.altKey) {
            remove_item(gData.links, link);
            Graph.graphData(getPrunedTree());
          } else {
            console.log(link);
            if (link.color === "blue") {
              link.__arrowObj.material.color = new THREE.Color(1, 0, 0);
              link.__photonsObj.children.forEach((mesh) => {
                mesh.material.color = new THREE.Color(1, 0, 0);
              });
              link.color = "red";
            } else {
              link.__arrowObj.material.color = new THREE.Color(0, 0, 1);
              link.__photonsObj.children.forEach((mesh) => {
                mesh.material.color = new THREE.Color(0, 0, 1);
              });
              link.color = "blue";
            }
            console.log(Graph.graphData());
          }
        })
        .linkDirectionalParticles((link) => (highlightLinks.has(link) ? 4 : 0))
        .linkDirectionalParticleWidth(1)
        .linkDirectionalParticleColor((link) => link.color)
        .linkDirectionalArrowColor((link) => link.color)
        .linkWidth(0)
        .onEngineTick(() => {
          gData.nodes.forEach((node) => {
            if (parseInt(node.name) < 0) {
              const main = gData.nodes[node.split - 1];
              ["x", "y", "z"].forEach((coord) => {
                if (coord !== "x") {
                  node[`f${coord}`] = main[coord];
                  main[`f${coord}`] = main[coord];
                } else {
                  node[`f${coord}`] = main[coord] - Graph.nodeRelSize() * 3.01;
                  main[`f${coord}`] = main[coord];
                }
              });
              if (node.hasOwnProperty("__threeObj")) {
                node.__threeObj.children[0].position.x =
                  main.__threeObj.children[0].position.x;
                let mat = new THREE.Matrix4();
                mat.set(
                  1,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  main["x"] + Graph.nodeRelSize(),
                  main["y"],
                  main["z"],
                  1
                );
                node.__threeObj.children[0].applyMatrix4(mat);
                node.__threeObj.children[0].matrixWorldNeedsUpdate = true;
              }
            }
          });
        })
        // misc settings
        .d3VelocityDecay(0.75)
        .postProcessingComposer()
        .addPass(bloomPass);

      Graph.d3Force("link").strength(0);
      Graph.d3Force("center").strength(0);
      Graph.d3Force("charge").strength((node, i, nodes) => {
        if (parseInt(node.name) < 0) {
          return 0;
        }
        return -30;
      });

      function keepCloning(objectpassed) {
        if (objectpassed === null || typeof objectpassed !== "object") {
          return objectpassed;
        }
        // give temporary-storage the original obj's constructor
        const temporary_storage = new THREE.MeshBasicMaterial();
        for (const key in objectpassed) {
          temporary_storage[key] = keepCloning(objectpassed[key]);
        }
        return temporary_storage;
      }
      function remove_item(arr, value) {
        let i = 0;
        while (i < arr.length) {
          if (arr[i] === value) {
            arr.splice(i, 1);
          } else {
            ++i;
          }
        }
        return arr;
      }
      //onchange for search bar
      document
        .getElementById("search_bar")
        .addEventListener("change", (event) => {
          let text = document.getElementById("search_bar").value.trim();
          Graph.graphData().nodes.forEach((node) => {
            if (node.label !== 0) {
              let container = document.getElementById(
                "node_container" + node.id.toString()
              );
              console.log(text);
              console.log(node.text);
              if (node.text.includes(text)) {
                container.style.display = "flex";
              } else {
                container.style.display = "none";
                console.log(container);
              }
            }
          });
        });
      // show and hide text
      document.addEventListener("keydown", (event) => {
        // console.log(event);
        if (event.key === "Escape") {
          selectedNodes.forEach((node) => {
            node.__threeObj.children[0].material.color.r /= 2;
            node.__threeObj.children[0].material.color.g /= 2;
            node.__threeObj.children[0].material.color.b /= 2;
            node.__threeObj.children[1].element.style.visibility = "hidden";
          });

          visible_nodes.forEach((node) => {
            node.__threeObj.children[1].element.style.visibility = "hidden";
          });
          selectedNodes.clear();
          highlightLinks.clear();
          visible_nodes.clear();
          updateHighlight();
        } else if (event.key === "ArrowUp") {
          visible_nodes.clear();
          gData.nodes.forEach((node) => {
        console.log(node);
          console.log(node.__threeObj);

            if (node.hasOwnProperty("__threeObj") && node.__threeObj.children[1] !== null) {
              node.__threeObj.children[1].element.style.visibility = "visible";
              visible_nodes.add(node);
            }
          });
        } else if (event.key === "ArrowDown") {
          gData.nodes.forEach((node) => {
        
            if (node.hasOwnProperty("__threeObj") && node.__threeObj.children[1] !== null) {
            node.__threeObj.children[1].element.style.visibility = "hidden";
            }
          });

          visible_nodes.clear();
        } else if (event.key === "-") {
          const current_size_px =
            gData.nodes[0].__threeObj.children[1].element.style.maxWidth;
          const desired_size = parseInt(current_size_px.slice(0, -2)) - 10;
          const desired_size_px = `${desired_size}px`;
          gData.nodes.forEach((node) => {
            node.__threeObj.children[1].element.style.maxWidth =
              desired_size_px;
            node.__threeObj.children[1].element.style.maxHeight =
              desired_size_px;
          });
        } else if (event.key === "+") {
          const current_size_px =
            gData.nodes[0].__threeObj.children[1].element.style.maxWidth;
          const desired_size = parseInt(current_size_px.slice(0, -2)) + 10;
          const desired_size_px = `${desired_size}px`;
          gData.nodes.forEach((node) => {
            node.__threeObj.children[1].element.style.maxWidth =
              desired_size_px;
            node.__threeObj.children[1].element.style.maxHeight =
              desired_size_px;
          });
        }
      });
      document.getElementById("add_submit").onclick = function () {
        let highest = 0;
        let i = gData.nodes.length - 1;
        while (highest === 0) {
          if (gData.nodes[i].label !== 0) {
            highest = gData.nodes[i].label + 1;
          } else i--;
        }
        gData.nodes.push({
          id: gData.nodes.length + 1,
          text: "",
          name: gData.nodes.length + 1,
          val: 10,
          neighbors: [],
          links: [],
          split: "",
          label: highest,
        });

        create_node(gData.nodes.at(-1));
        Graph.graphData(getPrunedTree());
      };

      document.addEventListener(
        "hide_dummy",
        (e) => {
          const check = gData.nodes.at(-1);
          gData.nodes.at(-1).__threeObj.visible = false;
          gData.nodes.at(-1).__threeObj.visible = false;
        },
        false
      );
      function updateHighlight() {
        // trigger update of highlighted objects in scene
        Graph.linkWidth(Graph.linkWidth()).linkDirectionalParticles(
          Graph.linkDirectionalParticles()
        );
      }
      function is_image(url) {
        return /\.(jpg|jpeg|png|webp|avif|gif|svg)$/.test(url);
      }
      function text_change(event) {
      Graph.d3Force('charge').strength(null);
      Graph.d3Force('link').strength(null);
      Graph.d3Force('center').strength(null);
        const field = event.target;
        const temp_id = field.parentElement.graph_id;
        console.log(temp_id);
        const target_node = gData.nodes.at(temp_id - 1);
        console.log(target_node);
        if (target_node.__threeObj.children[1] !== null) {
          target_node.__threeObj.children[1].removeFromParent();
        }

        if (is_image(field.value)) {
          const nodeEl = document.createElement("img");
          nodeEl.src = field.value;
          nodeEl.className = "node-label";
          nodeEl.id = `node_${temp_id}`;
          nodeEl.style.visibility = "hidden";
          nodeEl.style.objectFit = "contain";
          nodeEl.style.maxWidth = "100px";
          nodeEl.style.maxHeight = "100px";
          const css_obj = new THREE.CSS2DObject(nodeEl);
          target_node.__threeObj.add(css_obj);
          field.parentElement.children[1].children[0].checked = true;
        } else {
          const mesh = target_node.__threeObj.children[0];
          const nodeEl = document.createElement("div");
          nodeEl.textContent = field.value;
          nodeEl.className = "node-label";
          nodeEl.id = `node_${temp_id}`;
          nodeEl.style.visibility = "hidden";
          nodeEl.style.color = `rgb(${mesh.material.color.r * 2 * 255},${
            mesh.material.color.g * 2 * 255
          },${mesh.material.color.b * 2 * 255})`;
          const css_obj = new THREE.CSS2DObject(nodeEl);
          target_node.__threeObj.add(css_obj);
          field.parentElement.children[1].children[0].checked = false;
        }

        gData.nodes[temp_id - 1].text = field.value;
        Graph.graphData(getPrunedTree());
      }
      document.getElementById("download_file").onclick = function () {
        const pom = document.createElement("a");
        let db_string = '{"nodes":[';
        gData.nodes.forEach((node) => {
          db_string += `{"id": "${node.id}","name": "${node.name}","split": "${node.split}","val": ${node.val},"text": "${node.text}","label": ${node.label}},`;
        });
        db_string = db_string.slice(0, -1);
        db_string += '],"links":[';
        gData.links.forEach((link) => {
          db_string += `{"source": "${link.source.id}","color": "${link.color}","target": "${link.target.id}"},`;
        });
        if (gData.links.length > 0) {
          db_string = db_string.slice(0, -1);
        }
        db_string += "]}";

        pom.setAttribute(
          "href",
          `data:text/plain;charset=utf-8,${encodeURIComponent(db_string)}`
        );
        const currentdate = new Date();
        const datetime = `${currentdate.getDate()}-${
          currentdate.getMonth() + 1
        }-${currentdate.getFullYear()}_${currentdate.getHours()}-${currentdate.getMinutes()}-${currentdate.getSeconds()}.json`;
        if (
          document.getElementById("title_bar_div").children[0].innerText ===
          "Title"
        ) {
          pom.setAttribute("download", datetime);
        } else {
          pom.setAttribute(
            "download",
            document.getElementById("title_bar_div").children[0].innerText
          );
        }

        pom.style.display = "none";
        document.body.appendChild(pom);

        pom.click();

        document.body.removeChild(pom);
      };

        document.getElementById("title_bar_div").children[0].onclick = 
        function () {
          let bar_div = document.getElementById("title_bar_div");
          let first = bar_div.children[0];
          let last = bar_div.children[1];
        console.log(first);
        console.log(last);
          if (bar_div.getAttribute("data-editing") === "false") {
            first.style.display = "none";
            last.style.display = "block";
            last.value = first.innerText;
            bar_div.setAttribute("data-editing", "true");
            last.focus();
          }
        };
//      document.getElementById("title_bar_div").children[0].addEventListener('click',focus_title());

      document.getElementById("title_bar_textarea").onblur = function () {
        let text_area = document.getElementById("title_bar_textarea");
        let parent = text_area.parentElement;
        parent.children[0].innerText = text_area.value;
        parent.setAttribute("data-editing", "false");
        parent.children[0].style.display = "block";
        text_area.style.display = "none";
      };
        document.addEventListener('click',(event) => {
          let actions_cont = document.getElementById("node_actions");
          if (
            actions_cont.children[0].style.display === "block" &&
            event.target.className !== "action_creator"
          ) {
            for (const child of actions_cont.children) {
              child.style.display = "none";
            }
            actions_cont.style.top = "0px";
            actions_cont.style.right = "0px";
          }
        });
      document.getElementById("focus_button").onblur = function () {
        let actions_cont = document.getElementById("node_actions");
        for (const child of actions_cont.children) {
          child.style.display = "none";
        }
      };
      document.getElementById("select_button").onblur = function () {
        let actions_cont = document.getElementById("node_actions");
        for (const child of actions_cont.children) {
          child.style.display = "none";
        }
      };
      document.getElementById("split_button").onblur = function () {
        let actions_cont = document.getElementById("node_actions");
        for (const child of actions_cont.children) {
          child.style.display = "none";
        }
      };
      function create_node(node) {
        if (node.label !== 0) {
          const new_container = document.createElement("div");
          new_container.className = "content_container";
          new_container.graph_id = node.id;
          new_container.id = "node_container" + node.id.toString();
          const new_switch = document.createElement("label");
          new_switch.className = "switch";

          const new_checkbox = document.createElement("input");
          new_checkbox.type = "checkbox";
          const new_slider = document.createElement("span");
          new_slider.className = "slider";

          const new_num = document.createElement("h1");
          new_num.textContent = node.label;
          const new_textarea = document.createElement("textarea");
          new_textarea.className = "node_content";
          new_textarea.textContent = node.text;
          new_textarea.rows = "2";
          new_textarea.cols = "40";
          new_textarea.onchange = (event) => {
            text_change(event);
          };

          const new_focus = document.createElement("button");
          new_focus.type = "button";
          new_focus.className = "action_creator";
          new_focus.tabindex = "0";
          new_focus.onclick = (event) => {
            let actions_cont = document.getElementById("node_actions");

            for (const child of actions_cont.children) {
              child.style.display = "block";
              child.setAttribute("data-graphid", node.id);
            }
            actions_cont.style.top =
              event.target.getBoundingClientRect().top + "px";
            actions_cont.style.left =
              event.target.getBoundingClientRect().left +
              event.target.offsetWidth -
              actions_cont.offsetWidth +
              "px";
            //actions_cont.style.right = event.target.getBoundingClientRect().right+"px";
          };
          if (node.split == "") {
            const new_overlay = document.createElement("span");
            new_overlay.className = "slider_overlay";
            new_overlay.onclick = (event) => {
              event.target.remove();
            };
          }
          new_switch.appendChild(new_checkbox);
          new_switch.appendChild(new_slider);
          new_container.appendChild(new_num);
          new_container.appendChild(new_switch);
          new_container.appendChild(new_textarea);
          new_container.appendChild(new_focus);
          node_container.appendChild(new_container);
        }
      }
      document.getElementById("focus_button").onclick = function () {
        const temp_id = event.target.getAttribute("data-graphid");
        const node = gData.nodes.at(temp_id - 1);
        const distance = 40;
        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

        const newPos =
          node.x || node.y || node.z
            ? {
                x: node.x * distRatio,
                y: node.y * distRatio,
                z: node.z * distRatio,
              }
            : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

        Graph.cameraPosition(
          newPos, // new position
          node, // lookAt ({ x, y, z })
          3000 // ms transition duration
        );
      };

      document.getElementById("prune_button").onclick = function () {
        const temp_id = event.target.getAttribute("data-graphid");
        const node = gData.nodes.at(temp_id - 1);
        prune_keys.add(node);
        Graph.graphData(getPrunedTree());
      };

      document.getElementById("unprune_button").onclick = function () {
        const temp_id = event.target.getAttribute("data-graphid");
        const node = gData.nodes.at(temp_id - 1);
        prune_keys.delete(node);
        if (node.split !== "") {
          prune_keys.delete(gData.nodes[node.split - 1]);
        }
        Graph.graphData(getPrunedTree());
      };
      document.getElementById("select_button").onclick = function () {
        const temp_id = event.target.getAttribute("data-graphid");
        const node = gData.nodes.at(temp_id - 1);
        selectedNodes.has(node)
          ? selectedNodes.delete(node)
          : selectedNodes.add(node);
        if (selectedNodes.has(node)) {
          node.__threeObj.children[0].material.color.r *= 2;
          node.__threeObj.children[0].material.color.g *= 2;
          node.__threeObj.children[0].material.color.b *= 2;
          node.__threeObj.children[1].element.style.visibility = "visible";
          visible_nodes.add(node);
          visible_node = null;
          if (selectedNodes.size === 1) {
            if (node.links != null) {
              node.links.forEach((link) => highlightLinks.add(link));
              updateHighlight();
            }
          } else {
            highlightLinks.clear();
            selectedNodes.forEach((from_node) => {
              selectedNodes.forEach((to_node) => {
                if (from_node.links != null) {
                  from_node.links.forEach((link) => {
                    // console.log(link);
                    if (link.source === from_node && link.target === to_node) {
                      highlightLinks.add(link);
                    }
                    updateHighlight();
                  });
                }
              });
            });
          }
        } else {
          node.__threeObj.children[1].element.style.visibility = "hidden";
          visible_nodes.delete(node);
          node.__threeObj.children[0].material.color.r /= 2;
          node.__threeObj.children[0].material.color.g /= 2;
          node.__threeObj.children[0].material.color.b /= 2;
          highlightLinks.forEach((link) => {
            if (link.source === node || link.target === node) {
              highlightLinks.delete(link);
            }
            updateHighlight();
          });
        }
      };
      document.getElementById("split_button").onclick = function () {
        const temp_id = event.target.getAttribute("data-graphid");
        const node = gData.nodes.at(temp_id - 1);
        let temp_node = {
          id: gData.nodes.length + 1,
          name: "-" + node.id.toString(),
          val: 10,
          text: "",
          neighbors: [],
          links: [],
          split: node.id.toString(),
          index: gData.nodes.length - 1,
          label: 0,
        };
        console.log(temp_node);
        node.split = temp_node.id.toString();
        gData.nodes.push(temp_node);
        let temp_link = {
          source: node.id,
          target: temp_node.id,
          targetNode: temp_node,
          split: "1",
        };
        gData.links.push(temp_link);
        Graph.graphData(Graph.graphData());
        node.__threeObj.remove(node.__threeObj.children[0]);
        let geom = new THREE.SphereGeometry(
          NODE_REL_SIZE,
          64,
          32,
          Math.PI * 0.5,
          Math.PI,
          Math.PI,
          Math.PI
        );
        geom.scale(1, 1, 1);
        let mesh = new THREE.Mesh(
          geom,
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0, 0.5, 0.5),
            side: THREE.DoubleSide,
            //                    depthFunc:THREE.GreaterDepth
          })
        );
        mesh.updateMatrix();
        const group = new THREE.Group();
        group.add(mesh);
        console.log(node.__threeObj);
        const css_obj = node.__threeObj.children[0];

        node.__threeObj.add(mesh);
        node.__threeObj.add(css_obj);
      };
      document.getElementById("close_drop").onclick = function () {
        const drop_area = document.getElementById("drop_area");
        drop_area.style.display = "none";
      };
      document.getElementById("load_file").onclick = function () {
        const drop_area = document.getElementById("drop_area");
        drop_area.style.display = "block";
        drop_area.addEventListener("dragover", (event) => {
          event.stopPropagation();
          event.preventDefault();
          // Style the drag-and-drop as a "copy file" operation.
          event.dataTransfer.dropEffect = "copy";
        });

        drop_area.addEventListener("drop", (event) => {
          event.stopPropagation();
          event.preventDefault();
          const fileList = event.dataTransfer.files;
          const reader = new FileReader();
          let json_string = "";
          reader.addEventListener(
            "load",
            () => {
              // this will then display a text file
              json_string = reader.result;
              gData = JSON.parse(json_string);
              gData.links.forEach((link) => {
                const a = gData.nodes[link.source - 1];
                const b = gData.nodes[link.target - 1];
                if (!a.hasOwnProperty("neighbors")) {
                  a.neighbors = [];
                }
                if (!b.hasOwnProperty("neighbors")) {
                  b.neighbors = [];
                }
                !a.neighbors && (a.neighbors = []);
                !b.neighbors && (b.neighbors = []);
                a.neighbors.push(b);
                b.neighbors.push(a);

                if (a.links === null) {
                  a.links = [];
                }
                if (b.links === null) {
                  b.links = [];
                }
                !a.links && (a.links = []);
                !b.links && (b.links = []);
                a.links.push(link);
                b.links.push(link);
              });
              const old_containers =
                document.getElementsByClassName("content_container");
              for (let i = old_containers.length - 1; i >= 0; i--) {
                old_containers[i].remove();
              }
              gData.nodes.forEach((node) => {
                if (Object.keys(node).indexOf("neighbors") === -1) {
                  node.neighbors = [];
                }
                if (Object.keys(node).indexOf("links") === -1) {
                  node.links = [];
                }
                create_node(node);
              });
              Graph.graphData(getPrunedTree());
            },
            false
          );
          if (fileList[0]) {
            reader.readAsText(fileList[0]);
          }
          drop_area.style.display = "none";
        });
      };
    </script>
  </body>
</html>

<!--TO DO: refer to shapes, graph variable can be used to get node objects and set the parameters-->
<html>

<head>
  <style>
    body {
      margin: 0;
      height: 100vh;
      width: 100vw;
      display:flex;
      flex-direction:row;
      overflow:hidden !important;
    }
    #interface{
        height: 100%;
        width: 33.3333%;
        display:flex;
        flex-direction:column;
        padding: 1%;
    }
    #add_node{
        height:20%;
        width:100%;
        resize: none;
    }
    #add_submit{
        height:min-content;
        width:min-content;
        position:absolute;
        right:0;
        
    }
  </style>
  <script src="//unpkg.com/d3-dsv"></script>
  <script src="//unpkg.com/dat.gui"></script>
  <script src="//unpkg.com/d3-octree"></script>
  <script src="//unpkg.com/d3-force-3d"></script>
  <script src="//unpkg.com/three"></script>

  <script src="//unpkg.com/3d-force-graph"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>

<body>
    <div id="interface">
        <label for="add_node">Add Node</label>
        <textarea id="add_node" name = "add_node" rows="3" cols="50"></textarea>
        <span style="position:relative">
            <button type="button" id="add_submit">submit</button>
        </span>
        <canvas></canvas> 
    </div>
  <div id="3d-graph"></div>

  <script type="module">
    import { UnrealBloomPass } from '//cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js';

    const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
    const bloomLayer = new THREE.Layers();
    bloomLayer.set(BLOOM_SCENE);

    const materials = {};
    // controls
    const controls = { 'DAG Orientation': 'td' };
    const gui = new dat.GUI();
    gui.add(controls, 'DAG Orientation', ['td', 'bu', 'lr', 'rl', 'zout', 'zin', 'radialout', 'radialin', null])
      .onChange(orientation => graph && graph.dagMode(orientation));

    // graph config
    const NODE_REL_SIZE = 6;
    const graph = ForceGraph3D()
      .dagMode('td')
      .dagLevelDistance(200)
      .backgroundColor('#101020')
      .linkColor(() => 'rgba(255,255,255,0.2)')
      .nodeRelSize(NODE_REL_SIZE)
      .nodeId('path')
      .nodeVal('size')
      .nodeOpacity(0.9)
      .linkDirectionalParticles(2)
      .linkDirectionalParticleWidth(0.8)
      .linkDirectionalParticleSpeed(0.006)
      .d3Force('collision', d3.forceCollide(node => Math.cbrt(node.size) * NODE_REL_SIZE))
      .d3VelocityDecay(0.3);

    // Decrease repel intensity
    graph.d3Force('charge').strength(-15);

    // Graph Data 
    const nodes = [{ id: 1 }];
    const links = [];
    {% for node in raw_nodes %}
    nodes.push({ id: {{ node }}});
    {% endfor %}
    {% for pair in raw_links %}
    links.push({ source: {{ pair[0]}}, target: {{ pair[1]}}, targetNode: nodes[{{ pair[1]}}]});
    {% endfor %}
    const gData = {
      nodes, links
    };

    gData.links.forEach(link => {
      const a = gData.nodes[link.source];
      const b = gData.nodes[link.target];
      !a.neighbors && (a.neighbors = []);
      !b.neighbors && (b.neighbors = []);
      a.neighbors.push(b);
      b.neighbors.push(a);

      !a.links && (a.links = []);
      !b.links && (b.links = []);
      a.links.push(link);
      b.links.push(link);
    });
    // bloom config
    const bloomPass = new UnrealBloomPass();
    bloomPass.strength = 1;
    bloomPass.radius = 1;
    bloomPass.threshold = 0.5;
    const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
    let selectedNodes = new Set();
    let highlightLinks = new Set();
    var Graph = ForceGraph3D()(document.getElementById('3d-graph'));
    Graph.graphData(gData)
      .width(document.defaultView.innerWidth*2/3)
      .height(document.defaultView.innerHeight)
      .nodeLabel('id')
      .nodeColor((node) => node.id % 2 === 1 ? 'yellow' : 'blue')
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(0.5)
      .nodeThreeObject(node => new THREE.Mesh(
        new THREE.SphereGeometry(NODE_REL_SIZE),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(0, 0.5, 0.5) })
      )
      )
      .onNodeDrag((node, translate) => {
        if (selectedNodes.has(node)) { // moving a selected node
          [...selectedNodes]
            .filter(selNode => selNode !== node) // don't touch node being dragged
            .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = node[coord] + translate[coord])); // translate other nodes by same amount
        }
      })
      .onNodeDragEnd(node => {
        if (selectedNodes.has(node)) { // finished moving a selected node
          [...selectedNodes]
            .filter(selNode => selNode !== node) // don't touch node being dragged
            .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = undefined)); // unfix controlled nodes
        }
      })
      .onNodeClick((node, event) => {
        if (event.shiftKey) { // multi-selection
          selectedNodes.has(node) ? selectedNodes.delete(node) : selectedNodes.add(node);
          if (selectedNodes.has(node)) {
            node.__threeObj.material.color.r *= 2;
            node.__threeObj.material.color.g *= 2;
            node.__threeObj.material.color.b *= 2;
            if (selectedNodes.size === 1) {
              node.links.forEach(link => highlightLinks.add(link));
              updateHighlight();
            }
            else {
              highlightLinks.clear();
              selectedNodes.forEach(from_node => {
                selectedNodes.forEach(to_node => {
                  from_node.links.forEach(link => {
                    console.log(link);
                    if (link.source === from_node && link.target === to_node) {
                      highlightLinks.add(link);
                    }
                    updateHighlight();
                  });
                });
              });
            }
          }
          else{
            node.__threeObj.material.color.r /= 2;
            node.__threeObj.material.color.g /= 2;
            node.__threeObj.material.color.b /= 2;
            highlightLinks.forEach(link => {
              if (link.source === node || link.target === node) {
                highlightLinks.delete(link);
              }
              updateHighlight();
            });
          }
        }
          else if (event.ctrlKey){
          console.log(selectedNodes);
            selectedNodes.forEach(small_node =>{
            console.log(small_node.id);
            console.log(node.id);
            gData.links.push({source: small_node.id,target:node.id,targetNode:node});
            refresh();
          });
            console.log(gData.links[-1]);
          }
        else { // single-selection
          const untoggle = selectedNodes.has(node) && selectedNodes.size === 1;
          selectedNodes.clear();
          !untoggle && selectedNodes.add(node);
        }
      })
      .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .postProcessingComposer().addPass(bloomPass);

    document.getElementById("add_submit").onclick = function(){
        const input = document.getElementById("add_node").innerText;
        gData.nodes.push({id:nodes.size+1,text:input});
        refresh();
    };
    function refresh() {
      Graph.graphData(gData);
      Graph.refresh();
    }
    function updateHighlight() {
      // trigger update of highlighted objects in scene
      Graph
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }
  </script>
</body>

</html>
